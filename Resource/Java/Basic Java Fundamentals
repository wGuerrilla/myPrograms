Basic Java Fundamentals 

    Resources
        Youtube - broCode
            Dallas College - COSC 1437
                ChatGpt
--------------------------------------------------------------------
public class Main{
    public static void main(String[] args){
        System.out.println("wrldhello");
    }
}
// This is Source Code in a format humans can understand
// Class is a collection of related code within. more details later.
    // Within a class is whats called the main method. without this the code wont run.
// System.out.print();  prints input into system
// System.out.prinln(); THEN, creates a new line. you can also do \n 

public class Main{
    public static void main(String[] args){

        System.out.println("wrldhello");
    }
}
// Scope of Variable
// can it be seen?
// Scope defines the visibility and lifetime of variables.
// Variables can be global (Access throughout the whole progam)  Public 
//  Or local ( Limited through a specific block)                 Private 

// Value/Variable a placeholder for a value that behaves as the value it contains
    x = 123, y = "hi", z = False
    // variables can store numbers, words, or boolean values (T/F)
    data types - boolean, int, double, char, String   // there are 8 data types , we will use 4    !!!! Remember variables =/ datatypes !!!!!!
    size - 1 bit , 4 bytes, 8 bytes, 2 bytes, varies  // how much memory it holds
    PRimitive/                                          // Primitive datatypes - 8 types, stores data, can only hold 1 value, less memory, fast
    REference - PR, PR, PR, PR, RE;                     // Reference datatypes - unlimited(userdefine), stores an address, hold more than 1 value, more memory, slower
    value = true or false, -2billions - 2 billions,       // what each data type does.
            decimal up to 15 digits .0000., single ASCII value,
            "anything"
    // Declaration - Specifying\Creating a variable(datatype) requires us to declare it(variable name).  dataType (variablename);
    int x;
    // Assignment Operator ( = )  Value\Variable - taking the variable and assign it equal to a value                         variable(name) = value;
    x = 123;
    // Initialization - take the datatype followed by a variableName assign it equal to a value;    dataType v(ariablename) = value;
    int x = 123; // You Initialize when after assignment operater. 123. got it ?
// swaping two variables.
    // koolAid - if we have a glass of kool aid in Y, and a glass of Water in X, we need a third Glass to safely switch X and Y WITHOUT storing kool-aid in both values.4
    String x ="water";                  temp = x;   
    String y ="koolAid";                x = y;
    String temp;                        y = temp;

    // you either get kool-aid in both or water everywhere with temp you create a temporary storage.
// Using Scanner to Accept User-Input
// Scanner is found in the java utility package of your library 
    // we need to import it 

    import java.util.Scanner;

    public class Main{
        public static void main(String[] args){ // Preferable to use sc instead of a scannerName
            Scanner sc = new Scaneer(System.in);  // we are performing a litte bit of (OOP)objectOreintedProgramming
            // Ex. asking for a name
            System.out.println("Name;");
            String name = sc.nextLine();    // declare a variable, 4 string; take user input and assign it to a variable \\
            System.out.println("hello" + name);
            System.out.println("Numb;");
            Int oh = sc.nextInt();    // declare a integer variable  BE AWARE  when using nextInt and then going back to a STRING(nextLine)
            System.out.println(oh + "AllIzzWell"); // the programs will skip the user input because of an existing \n  within scanner that is active. (idk ) 
            sc.nextLine(); // scanner will read \n to clear it out do this.
            sc.close(); // it is a good practice to close scanner


        }
    }
// Expressions 
// a combination of operands & operators
// operands is the values, variables, numbers, or different quantities
// operators are the arithmetic sybols ( + , - , * , / , % )  //  ( <= , >= , < , > , ==, != )  a single equal assigns the variable
// // Constant - Valuethat cannot be changed
    fianl double dime = 0.10;
/////////
    Int dead = 10;
    double dead = (double)dead * 3; 
    // TYPE CASTING / use it appropiately.
    // Implcit casting : Automatically by the compilar
    // Explicit casting : DOne explicitly by the programmer using (conversion) operators();
    dead-- , dead++   // subtract/add

// Math Class Expressions
 public class MainP{
    public static void main(String[] args){
        double x = 3.14;
        double y = -10
        // Method 1 - Math.max(x, y) - the larger of two numbers
        // Method 2 - Math.min(x, y) - the lesser of two numbers
        // Method 3 - Math.abs(x) - absolute value
        // Method 4 - Math.sqrt(x) - Square root
        // Method 5 - Math.round(x) - rounded
        // Method 6 - Math.ceil(x) - round up
        // Method 7 - Math.floor(x) - round down
        z = Math.sqrt((x*x)+(y*y)) // be able to manipulate formulas.
    }
 }
 // Generating Random values
 import java.util.Random;

    public class Main{
        public static void main(String[] args){
            // Random can be done Alot of ways. we are going to use
            Math.random(); 
            int variableName = (int)(Math.random() * 101); // 101 allows us to get a number from 0 - 100 0;
    }
// If statements
public static Main{
    public static void main(String[] args){
        // If statement makes a TRUE or FALSE LOOP. if TRUE it exits the LOOP.
        // performs a block of code if it's condition evaluataes to true.^
        int age = 18;

        if(age >= 18){ // if true print
            System.out.println("u r grown");
        }else if(age >= 75){// check more then one condition
            System.out.println("wise men"); // if you are trying to get this number then move it to the main if (){};
        }   // otherwise. it would print 18 and the rest of the block gets ignored. since the first statement is true. loops get it?
        else{ // if its false then print
            System.out.println("u r young");
        }
    }
} Remember if( a == b && a == c ) is legal. if( a == b && c) is NOT legal // c needs a comparision.
// Flow Control in Java (or Any Programming Language)
    Flow control refers to how a program makes decisions and executes code 
        in a specific order based on conditions, loops, and function calls
        
        Java provides three main types of flow control:

        Sequential Flow ‚Üí Default execution (line-by-line).
        Selection (Decision-Making) Statements ‚Üí if, if-else, switch
        Iteration (Looping) Statements ‚Üí for, while, do-while
        Jump Statements ‚Üí break, continue, return
// For Loop (Fixed Reps)
    A for loop is used when the number of iterations is known beforehand.
// Loop iteration : Every time the loop runs and executes its statements, 
    // that is one iteration.
//
for (initialization; condition; update){ // EX. (int i = 1 ; i <= 5; i++)  Must use i = iteration
        Initialization ‚Üí Runs once before the loop starts.
        Condition ‚Üí Checked before each iteration. If true, the loop runs; otherwise, it stops.
        Update ‚Üí Changes the loop variable after each iteration.
}
// While Loop (Conditon - Based)
A while loop is used when the number of iterations is not known in advance 
    but depends on a condition.
    
while (condition){
    Condition ‚Üí Checked before each iteration.
    If true, the loop runs; if false, it stops.
    No automatic update, so you must update the loop variable inside manually.
}
Understand ? let me explain.
    public class WhileLoopExample{
        public static void main(String[] args)
        int = 1;

        while (i <= 5){
            System.out.println("Number: " + i)
            i++ // Increements to avoid infinite 
            ..// increase value iteration by 1 loop. if
            /// this is not place it would remain 1 forever.. looping as long
            /// as the condition is true.
        }
    }
    or 
        public static void main(String[] args){ /// The loop will keep prompting the user
        while(name.isBlank()){  /// to enter a name . if blank it loops under 
            System.out.println("Enter name : "); /// name variable is give by user input
            name = scanner.nextLine();
        }
            System.out.println("Hello " + name);
    }
// Do-While Loop
 do {                                   // Smiliar to while.. 
    System.out.println("Enter name : ");  // it will print the block of code once then check the condition
    name = scanner.nextLine() // rather then the while loop checking the condition first then printing the block of code.
 } while(name.isBlank());
    System.out.println("Hello " + name);
///   Some special keywords to take note.  ////
break; - stops Loop Immediately
 for(int i = 1; i <= 5; i++){
    if (i == 3 ){
        break; // Stop the loop when i == 3 
    }
    System.out.println(i); 1, 2 ,3
 }

 continue; - Skip Current Iteration
 for(int i = 1; i <= 5; i++){
    if (i == 3){
        continue; // Skip this iteration. skips 3 when i == 3.
    }
    System.out.println(i); 1, 2, 4, 5,
 }
///A Function (method) is a block of code that does a specific task. It can:
/// Take inputs (called parameters). parameters are (        ).
/// Return a value (or just perform an action).
/// Be reused multiple times without repeating code.
        public int add( int a, int b){ // visibility dataType variableName(declared dataType)
            return a + b;
        }

/// The name of the function is add, it must return an integer
/// The parameters are two integers a and b.
/// When they get a value, they become arguments.
/// Functions that are not VOID, are giving functions.
        public class Main{
            public static void main(String[] args){
                greet();
            }
            public static void greet(){
                System.out.println("hello");
            }
        }
        Since it doesnt return a value, theres no need for return.
    When to Use return?
    // If a function returns a value, that value should be:
    // Stored in a variable , Used in a condition , Passed into another function
    // KEEP IN MIND : void functions do not return value
            public class Main{
                public static void(String[] args){
                    int sum = add(4,20); // storing result
                    if (sum > 20){
                        System.out.println("bigGeekn")
                    }
                }
                public static int add(int a, int b){
                    return a + b;
                }
            }
// A class is a blueprint that contains methods and variables. In Java, every program must have a class.
// the add() is a method. we can do the same with other operators.
// Code from lecture
class Main{
    // Not static so we need an object to call it.
    public int addNumbers(int a, int b){
        int sum = a + b;  // once it adds. a and b are no longer visible 
        return sum;    // until we return it into sum
        // creating the function
    }
    // now to call the function to main // teacher likes static.
    public static void main(String[] args){
        int num1 = 25; 
        int num2 = 15;
        Main obj = new Main();  // Creating an object. remember new is keyword to creating objects
        int result = obj.addNumbers(num1, num2); // Calling the addNumbers method using the object
        System.out.print.ln("sum is " + sum);
    }
}
// allows program to run with an object 
// what does it look like without object?
class Main {
    // Now static, so we don't need an object to call it
    public static int addNumbers(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int num1 = 25, num2 = 15;
        
        // Calling the method directly without an object
        int result = addNumbers(num1, num2);
        
        System.out.println("Sum is " + result);
    }
}

// !! static means belonging to the class,
// while non-static means belonging to an object. aka Instance Variables. 
// its not fixed. each object has its own copy
/// String Methods.
    public class Main{
        public static void main(String[] args){
            String name = "bro";
            String nameTwo = "hoee";
            boolean result = name.equals("bro"); //comparing--- keep in mind every word and uppercase has to match.
            int result = name.length(); // how many numbers are in the string in total
            boolean result = name.equalsIgnoreCase("BRO") // Ignores upperCASE lowerCASE. hence da name
            // you can also just
            /// System.out.println(name.compareTo(nameTwo);  which gives 0 for true 1 for false
            /// you can also use IgnoreCase just add it after To .
        /// CODE FROM LECTURE
         if(name.equals(nameTwo)){
            System.out.println("True")} else{
            System.out.println("False")} // Same Concept.
            // if name > nameTwo returns postive value opposite is negative value 
            // if both are same numbers in total it will return 0.
        }
    }
// Arrays and ArrayList

import java.util.ArrayList;
import java.util.Arrays;

class Main{
    public static void main(String[] args){
        int[] Arrays = new int[2]; // Declaring an integer array with a fixed size of 2
        Arrays[0] = 1; // any number to be stored
        Arrays[1] = 2;
        System.out.println(Arrays[0]); 
        int[] myArrays = {1, 2, 3, 4, 5}; // this is a SHORT CUT to the above method.^
        System.out.println(myArrays[0]);  GOT IT 

        // Declaring an ArrayList of  Type Casting <dataTypes> it can only hold objects. 
        ArrayList<Integer> ArrList = new ArrayList<Integer>();
        ArrList.add(1); 
        ArrList.add(2);
        ArrList.add(3);
        System.out.println(ArrList.get(2)); // Access using .get( )
    }
}Arrays ‚Üí Fixed-size collections of elements of the same type.
ArrayLists ‚Üí Dynamic lists that can grow and shrink as needed.
import java.util.ArrayList; // Importing ArrayList class
// FOR LOOP  with Arrays. 
        System.out.println("Array Elements:");
        for (int i = 0; i < numbers.length; i++) { 
            System.out.println("Index " + i + ": " + numbers[i]);
        }
        // use appropiate typecasting on dataTypes.
        ArrayList<String> programmingLanguages = new ArrayList<>();

        // Adding 3 words to the ArrayList
        programmingLanguages.add("Java"); 
        programmingLanguages.add("Python"); 
        programmingLanguages.add("C++");

        // Printing all elements using a loop
        System.out.println("ArrayList Elements:");
        for (int i = 0; i < programmingLanguages.size(); i++) {  // you wont know the size for sure because its dynamic
            System.out.println("Index " + i + ": " + programmingLanguages.get(i));
        }
    }
// Arrys as Function Parameters
// This makes it easier to work with multiple values at once instead of passing them individually.
    public class ArrayAsFunction{
        int [] numbers = {1, 2, 3}; // Declare and initialize an array
        printArray(numbers); // Passing the entire array to a function 
    }
    public void printArry(int[] arr){ // This is a method that takess an integer array.
        for(int num : arr){ // Assign num to each loop cycle (3)
            System.out.println(num); // goes through each number ... interesting how we dont have to use int i = 0....
        }
    }
// since void is place we only get values. and return is not needed.
When Should You Use void?
‚úî When printing messages (System.out.println(...)).
‚úî When modifying variables but not needing a return value.
‚úî When performing an action, like updating a database or writing to a file.
/////////////////////////////////////////////////////////////////////////////////
/// ArrayList as Function Parameters
    import java.util.*;
    Array<String> names = new ArrayList<>(); // The <> (diamond operator) means we don‚Äôt need to specify String again.
    names.add("Alice");
    names.add("Bob");
    printList(names);

    public static void printList(ArrayList<String> list ) { 
        for (String item : list){System.out.println(item)}; // this outputs the string created above. 
    }
/// Arrays and ArrayList as Return values
public int[] createArray(){ 
    return new int[] {1, 2, 3}; 
}

public static ArrayList<String> createArraylist(){
    ArrayList<String> list = new ArrayList<>();   // we had to add createArrayList(){} function to call it to the main method 
    list.add("Dawg"); 
    list.add("Barks");
    return list; 
}
//////// MAIN METHOD //////
// public static void main(String[] args) {
//        // Calling the method that returns an array
//        int[] numbers = createArray();  // create a name for method
//        
//        // Printing the array elements using a loop
//        System.out.println("Array Elements:");
//        for (int num : numbers) {   // initiating num = for numbers 
//            System.out.println(num); // whereas a string we have to use String name : name : syntax
//        }
//
//        // Calling the method that returns an ArrayList
//        ArrayList<String> words = createArrayList(); 
//        
//        // Printing the ArrayList elements
//        System.out.println("ArrayList Elements:");git
//        for (String word : words) {   // the words and numbers : after the name seems to be from the system.
//            System.out.println(word);
//        }
//    }
////////////////

This one is a handful of information so I do my best for you.

            ///Understanding Classes 
    ///a class is a blueprint for creating objects
/// It defines attributes (fields/variables) and behaviors (methods/functions).
   attribute : (characteristics) Behaviors : (actions)
/// Basically as far as i understand  a class is not an actual object but defines what an object should look like. (characteristics)
    /// Attributes are variables inside a class that holds information about an object.
        public class Dog    {
            String name;    // no dog exists yet it just describe what the  // THIS IS AN ATTRIBUTE
            int age;        // dog will look like. Class blueprint is NOT a real ‚Äî it‚Äôs just a plan.
            String breed;   } // - this is how we store information on the plan. 
            ///Creating an object
    //An object is a real thing made from a class.
/// Dog refers to Dog class 
    public static void main(String[] args) {
        Dog myDog = new Dog(); // myDog is the name of the object
        // everytime you see, new, it creates an object in da computer.
        myDog.name = " buddy" ;  
        myDog.age = 3;  }// connect object with attribute. and assign it.  // THESE ARE ATTRIBUTE ASSIGNMENTS.

// Methods : define what an object can do .
void bark() {
    System.out.println(name + " says Woof! Woof!");
}

//  What are Access Modifiers?
Access modifiers control who can see and use the variables (attributes) and methods (behaviors) of a class.

Public  ‚Üí Any file can open and edit it.
Private ‚Üí Only that specific file can access it. password-proctecd only u use it.
Protected  ‚Üí Files in the same folder or related subfolders can access it.
Default  ‚Üí Only files in the same folder can open it.
//////////////////////////////////////////////////////////////////////////////////////////
    public class Dog{  // Accessible Anywher on computer.
        private String name; // restricted access within Dog{} // remember this is also called fields
        private int age; 
        private String breed; //  creating a dog object and assigning it will not work since these are private.
// Private attributes can only be accessed through methods inside the class.
        public void setName(String name){  // Use this method. 
            this.name = name; // assign provided value to private attributes.
        }
        public String getName(){
            return name;   // we allow the ability to set the name and get it when we need to ouput.
        }
    public class Main{
        public static void main(Stringp[] args){
            Dog myDog = new Dog();
            myDog.setName("Buddy");
            System.out.println("Dog's Name: " + myDog.getName()); // with this we can access private attributes.
        }
    }
}
// Protectected - if same folder - this code isint necessary.
// if in another folder.
public class Animal { 
    protected String beasts ;  
    protected void makeSound() {
        System.out.println("grr");
    }
}
// 
import folder.javaName; // optional... 
public class Dog extends Animal { // method to access protected.
    public Dog() {
        beasts = "Dog";
    }
     public void bark(){
    makeSound();
    System.out.println("Woof.")
    }
}  
// Default - default access
class Dog { }
public class Main { public (string[]){  myDog.name =" yapp"}}  // get the picture?



                    /// Constructors
/// a special method that Runs automatically when objects initialize
        /// has the same name as the class. no return type.
// Default Constructor 
// a no-argument constructor provided by Java if no other constructors are defined. can be explictly defined 
public Car(){
    make = "Umkown";
    model = " Unkown";
    year = 0;
}
// Dog Class with Constructor and private.
    public class Dog{
        private String Name;
        private int age;
        private String breed;
        
        public Dog(String name, int age, String breed){
            this.name = name;
            this.age = age;
            this.breed - breed;
        }
    }
     public class(){ } -   Dog myDog = new Dog("Buddy", 3 , " Golden ") // Automatically setting objects directly able to repeat this code.

// Multiple Constructors( Overloading)
// provide flexibility when creating objects:
    public Dog(String name){    // either by 
        this.name = name;   // create it with a name 
    }
    public Dog(String name, int age){
        this.name = name;   // or also with an age.
        this.age = age;
    }
// Introducing the Car Class
// ex attributes : make , model , year. 
// ex metods : start(), stop()
public class Car{
    private String make;
    private String model;
    private int year;
        public Car(){
            this.make = "n/a";   // defualt code outputed if  = new car () blank
            this.major = "n/a";
            this.year = "n/a";
        }
    // Since the variables are private we need to use get() Set()....
    public Car(String make, String model, int year){
        this.make = make;
        this.model = model;
        this.year = year;
        public string getMake(){
            return make;
        }   
        public void setMake(String make){ 
        this.make = make; // this gives us the ability to .setMake later on being able to change.
        }
    }
}
public class (){} - Car myCar = new Car("Toyota", "Camry", 2022)
    System.out.println(myCar.make + " " + myCar.model);

okay.. so  // private - constructor blank and one with all dataTypes. - getter return to make it public . - setter method for future updates. and Calling class.

// Encapsulation prevents direct access to attributes. We use getter methods to read data and setter methods to modify data safely.
// really helps protect data. 
// Encapsulation process - Declare variables as private , 
// provide public getter and setter methods.

// Unified-Modeling-Language 
UML shows attributes and methods in a class.
//  a visual representation of a design
    // key elements Classes, Attributes , Methods.
private : denoted by - 
public : denoted by + 
protected : denoted by #
        Car
---------------------         // use to plan and visualize projects
- engineStatus:boolean
- fuelLevel:double
----------------
+ startEngine()
+ stopEngine()
+ refuel(amount)
Best practices 
1 - keep Attributes Private
2 - provide necessary get and set
3 - use final for immutable data // final dollar, which a value that cannot change Use FINAL. something not to change
4 - Document methods // do comments

// Strings, Wrapper Classes, and Random Numbers 
    //A String is a sequence of characters (letters, numbers, symbols).
    //Example: "Hello, world!"
    //Strings are immutable, meaning once created, they cannot be changed.
    public class Main {
        public static void main(String[] args) {
            // Declaring a string
            String message = "Hello, world!";
            
            // Printing the string
            System.out.println(message); // Output: Hello, world!
        }
    }
    
//Class : Java Strings are objects of the String Class, they have useful methods
//length() returns the length of the string.
    String word = "Java";
    System.out.println(word.length());  // Output: 4
//charAt(Index) returns the character at a specific index..
    String word = "Java";
    System.out.println(word.charAt(1));  // Output: 'a' (Index starts at 0)
//subString(start, end) Extracts a portion of the string. 
    String sentence = "Hello, Java!";
    String part = sentence.substring(7, 11); // Extracts "Java"
//toUpperCas() and toLowerCase() change case. 
String text = "HeLLo";
System.out.println(text.toUpperCase()); // Output: HELLO
System.out.println(text.toLowerCase()); // Output: hello

// String Concatenation
    // - Use the "+" operator 
        String firstName = "Joe";
        String lastName = "Doe";
        String fullName = firstName + " " + lastName;
        System.out.println(fullName); // Output: Joe Doe
 

// Wrapper Classes 
// Wrapper classes convert primitive types (int, double, boolean) into objects.
// They allow objects to store primitive values.
Primitive Type  -	Wrapper Class
        int     -	Integer
        double  -	Double
        boolean -	Boolean
        char    -	Character

//Boxing & Unboxing (Converting Primitives & Objects)  // converts string of numbers to an wrapper class^
    // boxing
    int num = 10; 
    Integer obj = Integer.valueOf(num);  // Convert int to Integer object
    System.out.println(obj);  // Output: 10 
    // umboxing
    Integer obj = 20;
    int num = obj.intValue();  // Convert Integer object to int
    System.out.println(num);  // Output: 20
    
//"valueOf()": Converts a string to a wrapper object.
// "parseX()": converts a string to a primitibe type.
ex1.    
    String numStr = "123";
    int number = Integer.parseInt(numStr);  // Convert String to int
    double decimalNum = Double.parseDouble("3.14"); // Convert String to double

    System.out.println(number);  // Output: 123
    System.out.println(decimalNum);  // Output: 3.14

ex2.
    String numStr = "123";
    Integer obj = Integer.valueOf(numStr);
    system.out.println(obj);
// Random Number Generaators
//Generate pseudo-random numbers
import java.util.Random;

public class Main {
    public static void main(String[] args) {
        Random random = new Random();

        int num = random.nextInt(100) + 1;  // Generates number from 0 to 100
        System.out.println(num);
    }
}

// if these random number was private 
return random.nextInt();
or 
return Math.random(); // this may be wrong

// Random Numbers using Math Class
//Math.random() generates a double between 0.0 and 1.0
double randomDouble = Math.random(); // Between 0.0 and 1.0W
int randomInt = (int) (randomDouble * 100);  // Converts to 0-99
System.out.println(randomInt);


//strings + random 

// EX 1 
import java.util.Random;

public class Game {
    private String playerName;  // Private attribute (Encapsulation)
    private Random random = new Random();  // Random number generator making it private to secure. 

    // Constructor to initialize player name
    public Game(String playerName) {
        this.playerName = playerName;
    }

    // Method to play the game (Generates a random score)
    public void play() {
        int score = random.nextInt(100);  // Score between 0-99
        System.out.println(playerName + " scored " + score + " points!");
    }
}

public class Main {
    public static void main(String[] args) {
        Game player1 = new Game("Alice");
        player1.play();  // Example output: Alice scored 76 points!
    }
}

// EX 2
public class Game {
    private String playerName; // Encapsulation: private field

    // Constructor to set the player's name
    public Game(String playerName) {
        this.playerName = playerName;
    }

    // Play method using Math.random()
    public void play() {
        int score = (int) (Math.random() * 100); // Generates a number from 0 to 99
        System.out.println(playerName + " scored " + score);
    }
}

public class Main {
    public static void main(String[] args) {
        Game player1 = new Game("John"); // Create a Game object
        player1.play(); // Output: "John scored 45" (random number)
    }
}
// EX 3 
public class Game {
    private String playerName; // Encapsulation: private field

    // Constructor to set the player's name
    public Game(String playerName) {
        this.playerName = playerName;
    }

    // Private method to generate a random score
    private int generateRandomScore() {
        return (int) (Math.random() * 100); // Generates a number from 0 to 99
    }

    // Play method calls the private random number method
    public void play() {
        int score = generateRandomScore(); // Get a random score
        System.out.println(playerName + " scored " + score);
    }
}

public class Main {
    public static void main(String[] args) {
        Game player1 = new Game("John"); // Create a Game object
        player1.play(); // Output: "John scored 42" (random number)
    }
}
AGAIN
üîπ Object-Oriented Principles
OOP Principle	Definition	Example
Encapsulation	Hiding data inside a class and using methods to access it.	private String name; with getName() method.
Inheritance	A child class inherits properties from a parent class.	class Dog extends Animal {}
Polymorphism	The same method behaves differently for different objects.	makeSound() for Dog vs. Cat.

// Abstraction - Hiding complex details, showing only necessary parts.
// reduces complexity and increses code reusability
// so an understanding of abstract goes like. you go to a car dealership you ask for a vehicle
// the sales person ask for what type of vehicle .. if you say a vehicle he gonna think you crazy
// because vehicles are too abstract of an idea there is specific types of vehicles; car , truck, etc.
// so when the programmer tries to create Vehicle vehicle = new Vehicle(); the instance would not work due to abstract.
// creating security
// Abstract classes cannot be instantiated (you cannot create an object directly).
// Child classes must provide implementations for abstract methods.

    // Abstract class: Defines a blueprint but cannot be instantiated
    abstract class Animal {
        // Abstract method: Must be implemented by subclasses
        abstract void makeSound(); 
    }
    //A concrete class is a class that provides a complete implementation.^
    //It inherits (extends) from the abstract class and implements abstract methods.
    class Dog extends Animal{
        void makeSound(){   // abstract REQUIRES this code in order to function
            System.out.println("Bark");
        }
        void fetchBall() {
            System.out.println("Fetching the ball!");// ‚ùå ERROR! Animal does not have fetchBall()
        }
    }

    public class Main{
        public static void main(String[] args){
            Animal myDog = new Dog();  // this is an example of polymorphism and abstraction
            myDog.fetchBall(); // ‚ùå ERROR! Animal does not have fetchBall()
            myDog.makeSound();
        }
    }
    Animal my Dog = new Dog(); //	Refers to an object of type Dog but treats it as Animal. 
    // subclass treated by parent class.
    // Even though myDog stores a Dog object, it can ONLY use methods declared in Animal. hence abstract :)4

// Abstract Data Types (ADTs)
// define data and operations without specifying implementation details.

// A stack is a linear data structure that follows The last item added is the first one removed.
    //Think of a stack of plates:
    //You add plates to the top (push).
    //You remove the top plate first (pop).
    //You can check the top plate without removing it (peek).
    // you can also check if the stack is empty (isEmpty)
    import java.util.Stack;
    public class StackExample{
        public static void main(String[] args) {
            // Creating a Stack that stores Integer values
            Stack<Integer> stack = new Stack<>();

            // Pushing elements onto the stack (Adding values)
            stack.push(10); // Stack now contains: [10]
            stack.push(20); // Stack now contains: [10, 20]
            stack.push(30); // Stack now contains: [10, 20, 30]
             // Peeking (Checking the top element without removing it)
            System.out.println("Top element: " + stack.peek()); // Output: 30
            // Popping (Removing the top element)
             stack.pop(); // Removes 30, stack is now: [10, 20]
             // Displaying the stack after popping
            System.out.println("Stack after pop: " + stack); // Output: [10, 20]
        }
    }
// A queue is a linear data structure that follows the FIFO (First In, First Out) principle.
// Think of a line at a store checkout:z
//The first person to enter the line is served first.
    //Add (enqueue)	Inserts an element at the end of the queue.	
    //Poll (dequeue)	Removes and returns the front element.	
    //Peek	Returns the front element without removing it.	    
    //isEmpty	Checks if the queue is empty.
    import java.util.LinkedList;
    import java.util.Queue;

    public class QueueExample {
        public static void main(String[] args) {
            // Creating a Queue that stores Integer values
            Queue<Integer> queue = new LinkedList<>(); //  This means the queue will store integers.
    // In Java, a Queue is implemented using a LinkedList. Hence thee need for import
            // Enqueue (Adding elements to the queue)
            queue.add(1); // Queue: [1]
            queue.add(2); // Queue: [1, 2]
            queue.add(3); // Queue: [1, 2, 3]
    
            // Peeking (Checking the front element without removing it)
            System.out.println("Front element: " + queue.peek()); // Output: 1
    
            // Dequeue (Removing the front element)
            queue.poll(); // Removes 1, Queue is now: [2, 3]
    
            // Displaying the queue after removing an element
            System.out.println("Queue after poll: " + queue); // Output: [2, 3]
        }
    }
    
// File Writing in Java
//This code demonstrates how to write to a file in Java using FileWriter. 
// Let‚Äôs break it down, define key concepts, and explain how it works.
// Import required Java classes for file writing
import java.io.FileWriter;
import java.io.IOException;  // Handles potential file errors

public class FileWriteExample {
    public static void main(String[] args) {
        // Try-with-resources ensures FileWriter is closed automatically
        try (FileWriter writer = new FileWriter("output.txt")) { // If output.txt exists, it overwrites it. if not it creates a new file.
            // Writing text into the file
            writer.write("Hello, Java File Writing"); //Writes the string inside the output.txt
            
            // Confirmation message printed in the console
            System.out.println("File written successfully.");
        } 
        // Handling errors related to file operations
        catch (IOException e) {
            e.printStackTrace(); // Prints error details if writing fails
        }
    }
}
//////////////////////////////////////////////////////
        What Does This Code Do?
Creates (or overwrites) a file named output.txt.
Writes text ("Hello, Java File Writing") into the file.
Prints "File written successfully." in the console.
Handles potential errors using try-catch (to prevent crashes).
----------------------------------------------
    When Should You Use FileWriter?
Saving User Input	Store data entered by the user.
Logging System Events	Keep records of actions or errors.
Saving Game Progress	Store player stats, scores, and progress.
Generating Reports	Save reports in a .txt file.
////////////////////////////////////////////////


// In Java, try and catch are used to handle exceptions (errors) gracefully so that the program does not crash when something goes wrong.
    try block: Contains the code that might cause an exception.
    catch block: Handles the exception (error) if it occurs.
// so basically you can use this to keep a program running without crashing because you testing the code expecting a crash.


// File Reading in Java
// Import necessary classes for file reading
import java.io.File;  // Represents a file in Java
import java.io.FileNotFoundException;  // Exception if file is missing
import java.util.Scanner;  // Scanner to read file content

public class FileReadExample {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(new File("output.txt"))) { // Opens output.txt for reading- If the file does NOT exist, an error occurs.
            
            // Corrected loop: Reads the file line by line
            while (scanner.hasNextLine()) { 	// Returns true if another line exists in the file.
                System.out.println(scanner.nextLine()); // Reads and prints each line from the file
            }
        } catch (FileNotFoundException e) { // if file doesn't exist
            System.out.println("Error: File not found!"); // User-friendly error message
            e.printStackTrace(); // Print full error details (for debugging)
        }
    }
}

////////////////////////////////////////////////////
    What Does This Code Do?
Opens and reads a file named output.txt.
Prints each line from the file to the console.
Handles potential errors (e.g., if the file does not exist).
--------------------------------------------------------------
                When Should You Use File Reading?
Reading Configuration Files	Load user settings, app configurations, etc.
Processing Log Files	Analyze logs generated by applications.
Loading Game Data	Read saved game progress.
Reading User Input Files	Read user-generated content for processing.
/////////////////////////////////////////////////////////////////////////




















PRACTICE ACTITVITY (OPTIONAL)
// create a student class with:
// Fields : name, id, gpa.
// Constructor to initialize all fields. 
// Getter and Setter method. 
//Write the code to create and display a student object.
//we can also do a car and make two cars and have them race.


















chatgpt -- 
Variables - think of them as containers that store data values
    ex. int number = 5; // number is the variable that holds integer values
Methods - Blocks of code that perform specific tasks and can be called when needed.
    ex. public void greet(){
        System.out.println("hello world.")
    }
Object-Oriented Programming (OOP) Concepts
Java is a object-oriented programming language.
which means it uses objects to model real-world entitties.
dont get it ? Classes and Objects 
Class : A blueprint for creating objects. it defines attributes(variables) and behaviors(methods).
Objects: An instance of a class. It has its own state and can perform behaviors defined by its class.
    ex. public class Unkown{
        //Attributes 
        String color;
        String model;
        //Method
        public void Beast(){
            System.out.println("The Guerrilla on Da MOVE")
        }
    }
    //Creating an object
    Guerrilla myBeast = new Unkown();
    myBeast.color = "darkPurple";
    myBeast.weight = "300Ibs";
    myBeast.move();
Inheritance : A mechanism where one class(subclass) inherits attributes and methods
  // OPTIONAL : GENERATING RANDOM.
                //Random variableName = new Random();  // dataType variableName remember?
                //int x = variableName.nextInt();
                // understanding that if you want a number from 0 - 6... nextInt(7)
                //double y = variableName.nextDouble();
                // Manipulate as need for each dataType 
            }
// Graphical User Interface
// we the to impo+
import from library.;
import javax.swing.JOptionPane;

public class Main{
    public static void main(String[] args){
        String name = JOptionPane.showInputDialog(" blah "); // we need user input stored a string variable
        JOptionPane.showMessageDialog(null, " hi " + name); // show output of user input // 
        int ah = Integer.parseInt // when using dataType use the Apporiate Assignment to Intialize ?
           (JOptionPane.ShowInputDIalogBox(" aaa"))
         
    }
}
// Switches (Efficent If statement) 
// a statement that allows a variable to be tested for equality against a list of values, it cane execute a number of possible paths.
public class Main{
    public static void main(String[] args)
    String day ="Jummah"; // this is our first case. we are going to be using this to compare to the case..
    switch(day) { // manipulates any dataType
        case "yak" : System.out.println(" kho "); // case variableName : if there is a match what do you want to do ? 
        break;
        case "doo" : System.out.println(" kho ");
        break;
        // breaks off the code. why its important?
        // it prints all the code if not placed.
        default : System.out.println("chi meehgee");
        // if not is conditions is true then. it prints this. 
    }
}
